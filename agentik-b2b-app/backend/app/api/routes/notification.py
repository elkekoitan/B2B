from fastapi import APIRouter, Depends, HTTPException, status\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom app.core.auth import get_current_user_profile\nfrom app.core.database import get_db\nfrom app.models.email import Notification, NotificationCreate, NotificationType\nfrom app.models.common import APIResponse, PaginatedResponse, FilterParams\nfrom supabase import Client\nfrom loguru import logger\n\nrouter = APIRouter()\n\n@router.get(\"\", response_model=APIResponse[PaginatedResponse[Notification]])\nasync def get_notifications(\n    params: FilterParams = Depends(),\n    notification_type: Optional[NotificationType] = None,\n    read: Optional[bool] = None,\n    current_user = Depends(get_current_user_profile),\n    db: Client = Depends(get_db)\n):\n    \"\"\"Kullanıcının bildirimlerini getir\"\"\"\n    try:\n        # Query builder - sadece mevcut kullanıcının bildirimleri\n        query = db.table(\"notifications\").select(\"*\").eq(\n            \"user_id\", current_user[\"id\"]\n        )\n        \n        # Filters\n        if notification_type:\n            query = query.eq(\"type\", notification_type.value)\n        if read is not None:\n            query = query.eq(\"read\", read)\n        if params.search:\n            query = query.or_(f\"title.ilike.%{params.search}%,message.ilike.%{params.search}%\")\n        \n        # Pagination\n        offset = (params.page - 1) * params.size\n        query = query.range(offset, offset + params.size - 1)\n        \n        # Sorting\n        if params.sort_by:\n            ascending = params.sort_order == \"asc\"\n            query = query.order(params.sort_by, desc=not ascending)\n        else:\n            query = query.order(\"created_at\", desc=True)\n        \n        # Execute query\n        result = query.execute()\n        \n        # Get total count\n        count_query = db.table(\"notifications\").select(\n            \"id\", count=\"exact\"\n        ).eq(\"user_id\", current_user[\"id\"])\n        \n        if notification_type:\n            count_query = count_query.eq(\"type\", notification_type.value)\n        if read is not None:\n            count_query = count_query.eq(\"read\", read)\n        \n        count_result = count_query.execute()\n        total = count_result.count or 0\n        \n        has_next = (params.page * params.size) < total\n        has_previous = params.page > 1\n        \n        paginated_data = PaginatedResponse(\n            data=result.data or [],\n            total=total,\n            page=params.page,\n            size=params.size,\n            has_next=has_next,\n            has_previous=has_previous\n        )\n        \n        return APIResponse(\n            success=True,\n            data=paginated_data\n        )\n        \n    except Exception as e:\n        logger.error(f\"Notifications error: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Bildirimler alınırken hata oluştu\"\n        )\n\n@router.get(\"/unread-count\", response_model=APIResponse[dict])\nasync def get_unread_count(\n    current_user = Depends(get_current_user_profile),\n    db: Client = Depends(get_db)\n):\n    \"\"\"Okunmamış bildirim sayısını getir\"\"\"\n    try:\n        result = db.table(\"notifications\").select(\n            \"id\", count=\"exact\"\n        ).eq(\"user_id\", current_user[\"id\"]).eq(\n            \"read\", False\n        ).execute()\n        \n        unread_count = result.count or 0\n        \n        return APIResponse(\n            success=True,\n            data={\"unread_count\": unread_count}\n        )\n        \n    except Exception as e:\n        logger.error(f\"Unread count error: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Okunmamış bildirim sayısı alınırken hata oluştu\"\n        )\n\n@router.put(\"/{notification_id}/read\", response_model=APIResponse[Notification])\nasync def mark_notification_as_read(\n    notification_id: UUID,\n    current_user = Depends(get_current_user_profile),\n    db: Client = Depends(get_db)\n):\n    \"\"\"Bildirimi okundu olarak işaretle\"\"\"\n    try:\n        # Bildirimin varlığını ve yetkiyi kontrol et\n        notification_check = db.table(\"notifications\").select(\n            \"user_id\", \"read\"\n        ).eq(\"id\", str(notification_id)).single().execute()\n        \n        if not notification_check.data:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Bildirim bulunamadı\"\n            )\n        \n        if notification_check.data[\"user_id\"] != current_user[\"id\"]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Bu bildirimi görüntüleme yetkiniz yok\"\n            )\n        \n        # Zaten okunmuşsa güncelleme yapma\n        if notification_check.data[\"read\"]:\n            notification = db.table(\"notifications\").select(\"*\").eq(\n                \"id\", str(notification_id)\n            ).single().execute()\n            \n            return APIResponse(\n                success=True,\n                data=notification.data,\n                message=\"Bildirim zaten okunmuş\"\n            )\n        \n        # Okundu olarak işaretle\n        result = db.table(\"notifications\").update({\n            \"read\": True,\n            \"updated_at\": \"now()\"\n        }).eq(\"id\", str(notification_id)).execute()\n        \n        if not result.data:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Bildirim güncellenemedi\"\n            )\n        \n        # Güncellenmiş bildirimi getir\n        updated_notification = db.table(\"notifications\").select(\"*\").eq(\n            \"id\", str(notification_id)\n        ).single().execute()\n        \n        return APIResponse(\n            success=True,\n            data=updated_notification.data,\n            message=\"Bildirim okundu olarak işaretlendi\"\n        )\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Mark notification as read error: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Bildirim güncellenirken hata oluştu\"\n        )\n\n@router.put(\"/mark-all-read\", response_model=APIResponse[dict])\nasync def mark_all_notifications_as_read(\n    current_user = Depends(get_current_user_profile),\n    db: Client = Depends(get_db)\n):\n    \"\"\"Tüm bildirimleri okundu olarak işaretle\"\"\"\n    try:\n        result = db.table(\"notifications\").update({\n            \"read\": True,\n            \"updated_at\": \"now()\"\n        }).eq(\"user_id\", current_user[\"id\"]).eq(\n            \"read\", False\n        ).execute()\n        \n        updated_count = len(result.data) if result.data else 0\n        \n        return APIResponse(\n            success=True,\n            data={\"updated_count\": updated_count},\n            message=f\"{updated_count} bildirim okundu olarak işaretlendi\"\n        )\n        \n    except Exception as e:\n        logger.error(f\"Mark all notifications as read error: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Bildirimler güncellenirken hata oluştu\"\n        )\n\n@router.delete(\"/{notification_id}\", response_model=APIResponse[dict])\nasync def delete_notification(\n    notification_id: UUID,\n    current_user = Depends(get_current_user_profile),\n    db: Client = Depends(get_db)\n):\n    \"\"\"Bildirimi sil\"\"\"\n    try:\n        # Bildirimin varlığını ve yetkiyi kontrol et\n        notification_check = db.table(\"notifications\").select(\n            \"user_id\"\n        ).eq(\"id\", str(notification_id)).single().execute()\n        \n        if not notification_check.data:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Bildirim bulunamadı\"\n            )\n        \n        if notification_check.data[\"user_id\"] != current_user[\"id\"]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Bu bildirimi silme yetkiniz yok\"\n            )\n        \n        # Sil\n        result = db.table(\"notifications\").delete().eq(\n            \"id\", str(notification_id)\n        ).execute()\n        \n        return APIResponse(\n            success=True,\n            data={\"id\": str(notification_id)},\n            message=\"Bildirim başarıyla silindi\"\n        )\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Delete notification error: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Bildirim silinirken hata oluştu\"\n        )\n\n@router.post(\"\", response_model=APIResponse[Notification])\nasync def create_notification(\n    notification_data: NotificationCreate,\n    current_user = Depends(get_current_user_profile),\n    db: Client = Depends(get_db)\n):\n    \"\"\"Yeni bildirim oluştur (sistem yöneticileri için)\"\"\"\n    try:\n        # Admin kontrolü (isteğe bağlı - gerekirse eklenebilir)\n        # if current_user[\"role\"] != \"admin\":\n        #     raise HTTPException(\n        #         status_code=status.HTTP_403_FORBIDDEN,\n        #         detail=\"Bildirim oluşturma yetkiniz yok\"\n        #     )\n        \n        # Bildirim verilerini hazırla\n        create_data = notification_data.dict()\n        \n        # Supabase'e kaydet\n        result = db.table(\"notifications\").insert(create_data).execute()\n        \n        if not result.data:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Bildirim oluşturulamadı\"\n            )\n        \n        return APIResponse(\n            success=True,\n            data=result.data[0],\n            message=\"Bildirim başarıyla oluşturuldu\"\n        )\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Create notification error: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Bildirim oluşturulurken hata oluştu\"\n        )\n\n@router.get(\"/types\", response_model=APIResponse[List[str]])\nasync def get_notification_types(\n    db: Client = Depends(get_db)\n):\n    \"\"\"Mevcut bildirim tiplerini getir\"\"\"\n    try:\n        types = [type_item.value for type_item in NotificationType]\n        \n        return APIResponse(\n            success=True,\n            data=types\n        )\n        \n    except Exception as e:\n        logger.error(f\"Get notification types error: {e}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Bildirim tipleri alınırken hata oluştu\"\n        )\n